## vue3杂谈

#### 什么是组件

```vue
<div id="test">
  <div @click="handleClick">
    🐮🐮666
  </div>
  <p v-if="ifShow">{{value1}}</p>
  <p v-else>{{value2}}</p>
</div>
```

编译后

```js
const _Vue = Vue
const { createElementVNode: _createElementVNode, createCommentVNode: _createCommentVNode } = _Vue

const _hoisted_1 = ["onClick"]
const _hoisted_2 = { key: 0 }
const _hoisted_3 = { key: 1 }

return function render(_ctx, _cache) {
  with (_ctx) {
    const { createElementVNode: _createElementVNode, toDisplayString: _toDisplayString, openBlock: _openBlock, createElementBlock: _createElementBlock, createCommentVNode: _createCommentVNode, Fragment: _Fragment } = _Vue

    return (_openBlock(), _createElementBlock(_Fragment, null, [
      _createElementVNode("div", { onClick: handle }, " 🐮🐮666 ", 8 /* PROPS */, _hoisted_1),
      ifShow
        ? (_openBlock(), _createElementBlock("p", _hoisted_2, _toDisplayString(value1), 1 /* TEXT */))
        : (_openBlock(), _createElementBlock("p", _hoisted_3, _toDisplayString(value2), 1 /* TEXT */))
    ], 64 /* STABLE_FRAGMENT */))
  }
}
```

#### 虚拟DOM长啥样

```html
<template>
    <div>
        <div id="box1" class="test1">美食界里我老八</div>
        <div id="box2" class="test2">大家称我美食家</div>
    </div>
</template>
```

对应

```js
{
    tag: "div",
    props: {},
    children: [
        {
            tag: "div",
            props: {
                id: 'box1',
                class: 'test1'
            },
            children: ['美食界里我老八']
        },
        {
            tag: "div",
            props: {
                id: 'box2',
                class: 'test2'
            },
            children: ['大家称我美食家']
        }
    ]
}
```

粘一段大佬的分析，解决了之前对vue3源码的一些疑问

```js
export const enum ShapeFlags {
  ELEMENT = 1, // 普通节点
  FUNCTIONAL_COMPONENT = 1 << 1,//2 // 函数组件
  STATEFUL_COMPONENT = 1 << 2,//4 // 普通组件
  TEXT_CHILDREN = 1 << 3,//8 // 文本子节点
  ARRAY_CHILDREN = 1 << 4,//16 // 数组子节点
  SLOTS_CHILDREN = 1 << 5,//32
  TELEPORT = 1 << 6,//64 // 传送门
  SUSPENSE = 1 << 7,//128 // 可以在组件中异步
  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,//256
  COMPONENT_KEPT_ALIVE = 1 << 9,//512// keepALIVE
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT // 6 表示函数组件和普通组件
}
```

#### 响应式

```js
const obj = {
    count: 0
}

const proxy = reactive(obj)
```

// `reactive()` 是向用户暴露的 API，它真正执行的是 `createReactiveObject()` 函数

#### createReactiveObject

```typescript
function createReactiveObject(
  target: Target,
  isReadonly: boolean,
  baseHandlers: ProxyHandler<any>,
  collectionHandlers: ProxyHandler<any>
) {
  if (!isObject(target)) { // 是否是对象
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`)
    }
    return target
  }
  
  // target is already a Proxy, return it. 已经是响应式拉，就直接返回
  // exception: calling readonly() on a reactive object
  if (
    target[ReactiveFlags.raw] && 
    !(isReadonly && target[ReactiveFlags.isReactive])
  ) {
    return target
  }
  // target already has corresponding Proxy 已经被代理了
  if (
    hasOwn(target, isReadonly ? ReactiveFlags.readonly : ReactiveFlags.reactive)
  ) {
    return isReadonly
      ? target[ReactiveFlags.readonly]
      : target[ReactiveFlags.reactive]
  }
  // only a whitelist of value types can be observed. 不可被观察🕵
  if (!canObserve(target)) {
    return target
  }
 
  const observed = new Proxy(
    target,
    // 是普通的对象 Object 或 Array，处理器对象就使用 baseHandlers；如果是 Set, Map, WeakMap, WeakSet 中的一个，就使用collectionHandlers。
    collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers
  )
  def(
    target,
    isReadonly ? ReactiveFlags.readonly : ReactiveFlags.reactive, // 是否只读
    observed
  )
  
  return observed
}
```

#### baseHandlers

```typescript
import {
  reactive,
  readonly,
  toRaw,
  ReactiveFlags,
  Target,
  readonlyMap,
  reactiveMap,
  shallowReactiveMap,
  shallowReadonlyMap,
  isReadonly,
  isShallow
} from './reactive'
import { TrackOpTypes, TriggerOpTypes } from './operations'
import {
  track,
  trigger,
  ITERATE_KEY,
  pauseTracking,
  resetTracking
} from './effect'
import {
  isObject,
  hasOwn,
  isSymbol,
  hasChanged,
  isArray,
  isIntegerKey,
  extend,
  makeMap
} from '@vue/shared'
import { isRef } from './ref'

const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)

const builtInSymbols = new Set(
  Object.getOwnPropertyNames(Symbol)
    .map(key => (Symbol as any)[key])
    .filter(isSymbol)
)
// /*#__PURE__*/ 标识此为纯函数 不会有副作用 方便做 tree-shaking
const get = /*#__PURE__*/ createGetter()
const shallowGet = /*#__PURE__*/ createGetter(false, true)
const readonlyGet = /*#__PURE__*/ createGetter(true)
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)

const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()

function createArrayInstrumentations() {
  const instrumentations: Record<string, Function> = {}
  // instrument identity-sensitive Array methods to account for possible reactive
/*
instrument
n.
器械;仪器;器具;(车辆、机器的)仪器，仪表;促成某事的人(或事物);手段;受利用（或控制）的人;文据
v.
用仪器装备；为管弦乐队编(曲)；向…提交法律文件

一些敏感的数组方法可能造成响应式

'includes', 'indexOf', 'lastIndexOf' 被重写加以监听
*/
  // values
  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {
      /*
      在此处调用该函数
        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver)
        }
        如果 target 对象中指定了 getter，receiver 则为 getter 调用时的 this 值。所以这里的 this 指向 receiver，即 proxy 实例
      */
    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {
      const arr = toRaw(this) as any
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, TrackOpTypes.GET, i + '') // 收集依赖
      }
      // we run the method using the original args first (which may be reactive)
      const res = arr[key](...args)
      if (res === -1 || res === false) {
        // if that didn't work, run it again using raw values.
        return arr[key](...args.map(toRaw))
      } else {
        return res
      }
    }
  })
  // instrument length-altering mutation methods to avoid length being tracked
  // which leads to infinite loops in some cases (#2137)
  // 重写一些方法，响应式追踪
  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {
    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {
      pauseTracking() // 暂停响应式追踪
      const res = (toRaw(this) as any)[key].apply(this, args) // 应用源数据
      resetTracking() // 重新进行响应式追踪
      return res
    }
  })
  return instrumentations
}

function createGetter(isReadonly = false, shallow = false) {
  return function get(target: Target, key: string | symbol, receiver: object) {
    if (key === ReactiveFlags.IS_REACTIVE) {
      return !isReadonly
    } else if (key === ReactiveFlags.IS_READONLY) {
      return isReadonly
    } else if (key === ReactiveFlags.IS_SHALLOW) {
      return shallow
    } else if (
      key === ReactiveFlags.RAW &&
      receiver ===
        (isReadonly
          ? shallow
            ? shallowReadonlyMap
            : readonlyMap
          : shallow
          ? shallowReactiveMap
          : reactiveMap
        ).get(target)
    ) {
      return target
    }

    // 如果 target 是数组并且 key 属于三个方法之一 ['includes', 'indexOf', 'lastIndexOf']，即触发了这三个操作之一
    const targetIsArray = isArray(target)
	// 上门的判断结果将与!isReadonly && hasOwn(arrayInstrumentations, key)，同时触发Reflect.get（），
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver)
    }
	// 不管Proxy怎么修改默认行为，总可以在Reflect上获取默认行为。
    // 即是我们修改了proxy上的方法，在这里仍然将触发原来的行为
    // 拓展： Reflect.get使用函数形式来读取值
    const res = Reflect.get(target, key, receiver)

    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res
    }

    if (!isReadonly) {
      track(target, TrackOpTypes.GET, key)
    }

    if (shallow) {
      return res
    }

    if (isRef(res)) {
      // ref unwrapping - does not apply for Array + integer key.
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)
      return shouldUnwrap ? res.value : res
    }

    if (isObject(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      // 递归深层代理每一个值（我们使用const list = relative([])时，vue3将代理数组每一层的值）
      return isReadonly ? readonly(res) : reactive(res)
    }

    return res
  }
}

const set = /*#__PURE__*/ createSetter()
const shallowSet = /*#__PURE__*/ createSetter(true)

function createSetter(shallow = false) {
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean {
    let oldValue = (target as any)[key]
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value)
        oldValue = toRaw(oldValue)
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value
        return true
      }
    } else {
      // in shallow mode, objects are set as-is regardless of reactive or not
    }

    const hadKey =
      isArray(target) && isIntegerKey(key)
        ? Number(key) < target.length
        : hasOwn(target, key)
    const result = Reflect.set(target, key, value, receiver)
    // don't trigger if target is something up in the prototype chain of original
    // 不对自身原型上的属性进行依赖追踪
        if (target === toRaw(receiver)) {
      if (!hadKey) { // 如果 target 没有 key，就代表是新增操作，需要触发依赖
        trigger(target, TriggerOpTypes.ADD, key, value)
      } else if (hasChanged(value, oldValue)) {// 如果新旧值不相等，才触发依赖
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      }
    }
    return result
  }
}

function deleteProperty(target: object, key: string | symbol): boolean {
  const hadKey = hasOwn(target, key)
  const oldValue = (target as any)[key]
  const result = Reflect.deleteProperty(target, key)
  if (result && hadKey) {
    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)
  }
  return result
}

function has(target: object, key: string | symbol): boolean {
  const result = Reflect.has(target, key)
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, TrackOpTypes.HAS, key)
  }
  return result
}

function ownKeys(target: object): (string | symbol)[] {
  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)
  return Reflect.ownKeys(target)
}

export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
}

export const readonlyHandlers: ProxyHandler<object> = {
  get: readonlyGet,
  set(target, key) {
    if (__DEV__) {
      console.warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      )
    }
    return true
  },
  deleteProperty(target, key) {
    if (__DEV__) {
      console.warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      )
    }
    return true
  }
}

export const shallowReactiveHandlers = /*#__PURE__*/ extend(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
)

// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
// 对于props额外处理，他不是响应式解构，但是是响应式的读取
export const shallowReadonlyHandlers = /*#__PURE__*/ extend(
  {},
  readonlyHandlers,
  {
    get: shallowReadonlyGet
  }
)
```

#### effect()

```typescript
import { TrackOpTypes, TriggerOpTypes } from './operations'
import { extend, isArray, isIntegerKey, isMap } from '@vue/shared'
import { EffectScope, recordEffectScope } from './effectScope'
import {
  createDep,
  Dep,
  finalizeDepMarkers,
  initDepMarkers,
  newTracked,
  wasTracked
} from './dep'
import { ComputedRefImpl } from './computed'

// The main WeakMap that stores {target -> key -> dep} connections.
// Conceptually, it's easier to think of a dependency as a Dep class
// which maintains a Set of subscribers, but we simply store them as
// raw Sets to reduce memory overhead.
type KeyToDepMap = Map<any, Dep>
const targetMap = new WeakMap<any, KeyToDepMap>()

// The number of effects currently being tracked recursively.
let effectTrackDepth = 0

export let trackOpBit = 1

/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */
const maxMarkerBits = 30

export type EffectScheduler = (...args: any[]) => any

export type DebuggerEvent = {
  effect: ReactiveEffect
} & DebuggerEventExtraInfo

export type DebuggerEventExtraInfo = {
  target: object
  type: TrackOpTypes | TriggerOpTypes
  key: any
  newValue?: any
  oldValue?: any
  oldTarget?: Map<any, any> | Set<any>
}

export let activeEffect: ReactiveEffect | undefined

export const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')
export const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')

export class ReactiveEffect<T = any> {
  active = true
  deps: Dep[] = []
  parent: ReactiveEffect | undefined = undefined

  /**
   * Can be attached after creation
   * @internal
   */
  computed?: ComputedRefImpl<T>
  /**
   * @internal
   */
  allowRecurse?: boolean

  onStop?: () => void
  // dev only
  onTrack?: (event: DebuggerEvent) => void
  // dev only
  onTrigger?: (event: DebuggerEvent) => void

  constructor(
    public fn: () => T,
    public scheduler: EffectScheduler | null = null,
    scope?: EffectScope // 允许重写依赖追踪和收集
  ) {
    recordEffectScope(this, scope) // 收集依赖
  }

  run() {
    if (!this.active) {
      return this.fn()
    }
    let parent: ReactiveEffect | undefined = activeEffect
    let lastShouldTrack = shouldTrack
    while (parent) {
      if (parent === this) {
        return
      }
      parent = parent.parent
    }
    // 在当前所有活跃的依赖中挑出是当前实例的依赖
    try {
      this.parent = activeEffect
      activeEffect = this
      shouldTrack = true

      trackOpBit = 1 << ++effectTrackDepth
	  // 依赖最深收录到30层，
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this)
      } else {
        cleanupEffect(this)
      }
      return this.fn()
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this)
      }

      trackOpBit = 1 << --effectTrackDepth

      activeEffect = this.parent
      shouldTrack = lastShouldTrack
      this.parent = undefined
    }
  }

  stop() {
    if (this.active) {
      cleanupEffect(this)
      if (this.onStop) {
        this.onStop()
      }
      this.active = false
    }
  }
}

// 让 effect 关联下的所有 dep 实例清空 effect，即清除这个依赖函数。
function cleanupEffect(effect: ReactiveEffect) {
  const { deps } = effect
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect)
    }
    deps.length = 0
  }
}

export interface DebuggerOptions {
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}

export interface ReactiveEffectOptions extends DebuggerOptions {
  lazy?: boolean // 延迟计算，为true时候，传入的effect不会立即执行。
  scheduler?: EffectScheduler // 调度器函数，接受的入参run即是传给effect的函数，如果传了scheduler，则可通过其调用监听函数。
  scope?: EffectScope
  // 此处查看https://v3.cn.vuejs.org/api/effect-scope.html#effectscope，就知道这个配置项是什么了，为什么要把这一块提取出来
  allowRecurse?: boolean
  onStop?: () => void // 调度器函数，接受的入参run即是传给effect的函数，如果传了scheduler，则可通过其调用监听函数。
}

export interface ReactiveEffectRunner<T = any> {
  (): T
  effect: ReactiveEffect
}

export function effect<T = any>(
  fn: () => T,
  options?: ReactiveEffectOptions
): ReactiveEffectRunner {
  // 如果该函数已经是监听函数了，那赋值fn为该函数的原始函数
  if ((fn as ReactiveEffectRunner).effect) {
    fn = (fn as ReactiveEffectRunner).effect.fn
  }
  // 创建 effect 
  const _effect = new ReactiveEffect(fn)
  if (options) { 
    extend(_effect, options)
    if (options.scope) recordEffectScope(_effect, options.scope)
  }
  if (!options || !options.lazy) {// 如果不是延迟执行的话，立即执行一次
    _effect.run()
  }
  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner
  runner.effect = _effect
  return runner
}

export function stop(runner: ReactiveEffectRunner) {
  runner.effect.stop()
}

export let shouldTrack = true
const trackStack: boolean[] = []

export function pauseTracking() {
  trackStack.push(shouldTrack)
  shouldTrack = false
}

export function enableTracking() {
  trackStack.push(shouldTrack)
  shouldTrack = true
}

export function resetTracking() {
  const last = trackStack.pop()
  shouldTrack = last === undefined ? true : last
}

export function track(target: object, type: TrackOpTypes, key: unknown) {
  if (shouldTrack && activeEffect) { // 当前实例依赖存在且允许收集依赖
    let depsMap = targetMap.get(target) // targetMap 依赖管理中心，用于收集依赖和触发依赖
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map()))
    }
  // 摘抄一段大佬的，
  // targetMap 为每个 target 建立一个 map
  // 每个 target 的 key 对应着一个 dep
  // 然后用 dep 来收集依赖函数，当监听的 key 值发生变化时，触发 dep 中的依赖函数
  // 类似于这样
  // targetMap(weakmap) = {
  //     target1(map): {
  //       key1(dep): (fn1,fn2,fn3...)
  //       key2(dep): (fn1,fn2,fn3...)
  //     },
  //     target2(map): {
  //       key1(dep): (fn1,fn2,fn3...)
  //       key2(dep): (fn1,fn2,fn3...)
  //     },
  // }
    let dep = depsMap.get(key)
    if (!dep) {
      depsMap.set(key, (dep = createDep()))
    }
	// dev环境一些配置
    const eventInfo = __DEV__
      ? { effect: activeEffect, target, type, key }
      : undefined

    trackEffects(dep, eventInfo)
  }
}

export function trackEffects(
  dep: Dep,
  debuggerEventExtraInfo?: DebuggerEventExtraInfo
) {
  let shouldTrack = false
  if (effectTrackDepth <= maxMarkerBits) { // 在最大依赖限度之内
    if (!newTracked(dep)) {
      dep.n |= trackOpBit // set newly tracked
      shouldTrack = !wasTracked(dep)
    }
  } else {
    // Full cleanup mode.
    shouldTrack = !dep.has(activeEffect!)
  }
  // 上面在做什么啊，（|= 位运算）意思为：按位或后赋值，
  // 搞不清楚，应该是处理一些假如不允许收集依赖的情况

  if (shouldTrack) {
    dep.add(activeEffect!)
    activeEffect!.deps.push(dep)
    // dev环境执行onTrack()
    if (__DEV__ && activeEffect!.onTrack) {
      activeEffect!.onTrack(
        Object.assign(
          {
            effect: activeEffect!
          },
          debuggerEventExtraInfo
        )
      )
    }
  }
}

export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map<unknown, unknown> | Set<unknown>
) {
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    // never been tracked 如果没有收集过依赖，直接返回
    return
  }

    /*
    track 的类型
    export const enum TrackOpTypes {
      GET = 'get', // get 操作
      HAS = 'has', // has 操作
      ITERATE = 'iterate' // ownKeys 操作
    }

    trigger 的类型
    export const enum TriggerOpTypes {
      SET = 'set', // 设置操作，将旧值设置为新值
      ADD = 'add', // 新增操作，添加一个新的值 例如给对象新增一个值 数组的 push 操作
      DELETE = 'delete', // 删除操作 例如对象的 delete 操作，数组的 pop 操作
      CLEAR = 'clear' // 用于 Map 和 Set 的 clear 操作。
    }
    */
  let deps: (Dep | undefined)[] = []
  if (type === TriggerOpTypes.CLEAR) {
    // collection being cleared
    // trigger all effects for target
    // 在值被清空前，往相应的队列添加 target 所有的依赖,清除集合将触发目标的所有效果
    deps = [...depsMap.values()]
  } else if (key === 'length' && isArray(target)) { // 当数组的 length 属性变化时触发
    depsMap.forEach((dep, key) => {
      if (key === 'length' || key >= (newValue as number)) {
        deps.push(dep)
      }
    })
  } else {
    // schedule runs for SET | ADD | DELETE
    if (key !== void 0) {
      deps.push(depsMap.get(key))
    }

    // also run for iteration key on ADD | DELETE | Map.SET
    switch (type) {
      case TriggerOpTypes.ADD:
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY))
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))
          }
        } else if (isIntegerKey(key)) {
          // new index added to array -> length changes
          deps.push(depsMap.get('length')) // length改变也将添加到依赖
        }
        break
      case TriggerOpTypes.DELETE:
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY))
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))
          }
        }
        break
      case TriggerOpTypes.SET:
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY))
        }
        break
    }
  }

  const eventInfo = __DEV__
    ? { target, type, key, newValue, oldValue, oldTarget }
    : undefined

  if (deps.length === 1) {
    if (deps[0]) {
      if (__DEV__) {
        triggerEffects(deps[0], eventInfo)
      } else {
        triggerEffects(deps[0])
      }
    }
  } else {
    const effects: ReactiveEffect[] = []
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep)
      }
    }
    if (__DEV__) {
      triggerEffects(createDep(effects), eventInfo)
    } else {
      triggerEffects(createDep(effects))
    }
  }
}

export function triggerEffects(
  dep: Dep | ReactiveEffect[],
  debuggerEventExtraInfo?: DebuggerEventExtraInfo
) {
  // spread into array for stabilization
  for (const effect of isArray(dep) ? dep : [...dep]) {
    if (effect !== activeEffect || effect.allowRecurse) {
      if (__DEV__ && effect.onTrigger) {
        effect.onTrigger(extend({ effect }, debuggerEventExtraInfo))
      }
      if (effect.scheduler) {
        effect.scheduler()
      } else {
        effect.run()
      }
    }
  }
}
```

#### 响应式数据和 track() trigger() 的配合

```js
let test = '🐮'
const testObj = reactive({ value: ‘🐎’ }) // 对 `{ num: 0 }` 进行监听，返回一个 proxy 实例
effect(() => (test = testObj.value)) // 创建一个依赖，并且在创建时会执行一次fn。fn()读取value的值，并赋值给test。
/*
读取属性这个操作会触发 proxy 的属性读取拦截操作,在拦截操作里会去收集依赖，

*/

console.log(test == '🐎')
testObj.value = ‘🍔’
/*
此处赋值操作也会触发proxy，
1. 返回新值
2. 收集依赖
3. 给test赋值
*/
console.log(test == ‘🍔’)
```

具体执行流程

![image][id_0]

#### effectScope

```typescript
import { ReactiveEffect } from './effect'
import { warn } from './warning'

let activeEffectScope: EffectScope | undefined

export class EffectScope {
  active = true
  effects: ReactiveEffect[] = []
  cleanups: (() => void)[] = []

  parent: EffectScope | undefined
  scopes: EffectScope[] | undefined
  /**
   * track a child scope's index in its parent's scopes array for optimized
   * removal
   */
  private index: number | undefined

  constructor(detached = false) {
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope
      this.index =
        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1
    }
  }

  run<T>(fn: () => T): T | undefined {
    if (this.active) {
      try {
        activeEffectScope = this
        return fn()
      } finally {
        activeEffectScope = this.parent
      }
    } else if (__DEV__) {
      warn(`cannot run an inactive effect scope.`)
    }
  }

  on() {
    activeEffectScope = this
  }

  off() {
    activeEffectScope = this.parent
  }

  stop(fromParent?: boolean) {
    if (this.active) {
      let i, l
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop()
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]()
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true)
        }
      }
      // nested scope, dereference from parent to avoid memory leaks
      if (this.parent && !fromParent) {
        // optimized O(1) removal
        const last = this.parent.scopes!.pop()
        if (last && last !== this) {
          this.parent.scopes![this.index!] = last
          last.index = this.index!
        }
      }
      this.active = false
    }
  }
}

export function effectScope(detached?: boolean) {
  return new EffectScope(detached)
}

export function recordEffectScope(
  effect: ReactiveEffect,
  scope: EffectScope | undefined = activeEffectScope
) {
  if (scope && scope.active) {
    scope.effects.push(effect)
  }
}

export function getCurrentScope() {
  return activeEffectScope
}

export function onScopeDispose(fn: () => void) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn)
  } else if (__DEV__) {
    warn(
      `onScopeDispose() is called when there is no active effect scope` +
        ` to be associated with.`
    )
  }
}
```

#### ref

```typescript
import {
  activeEffect,
  shouldTrack,
  trackEffects,
  triggerEffects
} from './effect'
import { TrackOpTypes, TriggerOpTypes } from './operations'
import { isArray, hasChanged, IfAny } from '@vue/shared'
import { isProxy, toRaw, isReactive, toReactive } from './reactive'
import type { ShallowReactiveMarker } from './reactive'
import { CollectionTypes } from './collectionHandlers'
import { createDep, Dep } from './dep'

declare const RefSymbol: unique symbol

export interface Ref<T = any> {
  value: T
  /**
   * Type differentiator only.
   * We need this to be in public d.ts but don't want it to show up in IDE
   * autocomplete, so we use a private Symbol instead.
   */
  [RefSymbol]: true
}

type RefBase<T> = {
  dep?: Dep
  value: T
}

export function trackRefValue(ref: RefBase<any>) {
  if (shouldTrack && activeEffect) {
    ref = toRaw(ref)
    if (__DEV__) {
      trackEffects(ref.dep || (ref.dep = createDep()), {
        target: ref,
        type: TrackOpTypes.GET,
        key: 'value'
      })
    } else {
      trackEffects(ref.dep || (ref.dep = createDep()))
    }
  }
}

export function triggerRefValue(ref: RefBase<any>, newVal?: any) {
  ref = toRaw(ref)
  if (ref.dep) {
    if (__DEV__) {
      triggerEffects(ref.dep, {
        target: ref,
        type: TriggerOpTypes.SET,
        key: 'value',
        newValue: newVal
      })
    } else {
      triggerEffects(ref.dep)
    }
  }
}

export function isRef<T>(r: Ref<T> | unknown): r is Ref<T>
export function isRef(r: any): r is Ref {
  return !!(r && r.__v_isRef === true)
}

export function ref<T extends object>(
  value: T
): [T] extends [Ref] ? T : Ref<UnwrapRef<T>>
export function ref<T>(value: T): Ref<UnwrapRef<T>>
export function ref<T = any>(): Ref<T | undefined>
export function ref(value?: unknown) {
  return createRef(value, false)
}

declare const ShallowRefMarker: unique symbol

export type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }

export function shallowRef<T extends object>(
  value: T
): T extends Ref ? T : ShallowRef<T>
export function shallowRef<T>(value: T): ShallowRef<T>
export function shallowRef<T = any>(): ShallowRef<T | undefined>
export function shallowRef(value?: unknown) {
  return createRef(value, true)
}

function createRef(rawValue: unknown, shallow: boolean) {
  if (isRef(rawValue)) { // 如果直接是ref，就直接返回啥也不干
    return rawValue
  }
  return new RefImpl(rawValue, shallow) // new一个新的ref
}
// 真正创建ref
class RefImpl<T> {
  private _value: T
  private _rawValue: T

  public dep?: Dep = undefined
  public readonly __v_isRef = true // 标识为ref对象

  constructor(value: T, public readonly __v_isShallow: boolean) {
    this._rawValue = __v_isShallow ? value : toRaw(value)
    this._value = __v_isShallow ? value : toReactive(value)
  }

  // get set 分别进行依赖收集与追踪
  get value() {
    trackRefValue(this) // 追踪
    return this._value // 返回值（类似于relative）
  }

  set value(newVal) { // ........
    newVal = this.__v_isShallow ? newVal : toRaw(newVal)
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal
      this._value = this.__v_isShallow ? newVal : toReactive(newVal)
      triggerRefValue(this, newVal) // 收集
    }
  }
  /*
  get先追再返回
  set先设置再收集，（设置完才能收集啊emmmmmm）
  */
}

export function triggerRef(ref: Ref) {
  triggerRefValue(ref, __DEV__ ? ref.value : void 0)
}

export function unref<T>(ref: T | Ref<T>): T {
  return isRef(ref) ? (ref.value as any) : ref
}

const shallowUnwrapHandlers: ProxyHandler<any> = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key]
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value
      return true
    } else {
      return Reflect.set(target, key, value, receiver)
    }
  }
}

export function proxyRefs<T extends object>(
  objectWithRefs: T
): ShallowUnwrapRef<T> {
  return isReactive(objectWithRefs)
    ? objectWithRefs
    : new Proxy(objectWithRefs, shallowUnwrapHandlers)
}

export type CustomRefFactory<T> = (
  track: () => void,
  trigger: () => void
) => {
  get: () => T
  set: (value: T) => void
}

class CustomRefImpl<T> {
  public dep?: Dep = undefined

  private readonly _get: ReturnType<CustomRefFactory<T>>['get']
  private readonly _set: ReturnType<CustomRefFactory<T>>['set']

  public readonly __v_isRef = true

  constructor(factory: CustomRefFactory<T>) {
    const { get, set } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    )
    this._get = get
    this._set = set
  }

  get value() {
    return this._get()
  }

  set value(newVal) {
    this._set(newVal)
  }
}

export function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {
  return new CustomRefImpl(factory) as any
}

export type ToRefs<T = any> = {
  [K in keyof T]: ToRef<T[K]>
}
export function toRefs<T extends object>(object: T): ToRefs<T> {
  if (__DEV__ && !isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`)
  }
  const ret: any = isArray(object) ? new Array(object.length) : {}
  for (const key in object) {
    ret[key] = toRef(object, key)
  }
  return ret
}

class ObjectRefImpl<T extends object, K extends keyof T> {
  public readonly __v_isRef = true

  constructor(
    private readonly _object: T,
    private readonly _key: K,
    private readonly _defaultValue?: T[K]
  ) {}

  get value() {
    const val = this._object[this._key]
    return val === undefined ? (this._defaultValue as T[K]) : val
  }

  set value(newVal) {
    this._object[this._key] = newVal
  }
}

export type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>

export function toRef<T extends object, K extends keyof T>(
  object: T,
  key: K
): ToRef<T[K]>

export function toRef<T extends object, K extends keyof T>(
  object: T,
  key: K,
  defaultValue: T[K]
): ToRef<Exclude<T[K], undefined>>

export function toRef<T extends object, K extends keyof T>(
  object: T,
  key: K,
  defaultValue?: T[K]
): ToRef<T[K]> {
  const val = object[key]
  return isRef(val)
    ? val
    : (new ObjectRefImpl(object, key, defaultValue) as any)
}

// corner case when use narrows type
// Ex. type RelativePath = string & { __brand: unknown }
// RelativePath extends object -> true
type BaseTypes = string | number | boolean

/**
 * This is a special exported interface for other packages to declare
 * additional types that should bail out for ref unwrapping. For example
 * \@vue/runtime-dom can declare it like so in its d.ts:
 *
 * ``` ts
 * declare module '@vue/reactivity' {
 *   export interface RefUnwrapBailTypes {
 *     runtimeDOMBailTypes: Node | Window
 *   }
 * }
 * ```
 *
 * Note that api-extractor somehow refuses to include `declare module`
 * augmentations in its generated d.ts, so we have to manually append them
 * to the final generated d.ts in our build process.
 */
export interface RefUnwrapBailTypes {}

export type ShallowUnwrapRef<T> = {
  [K in keyof T]: T[K] extends Ref<infer V>
    ? V
    : // if `V` is `unknown` that means it does not extend `Ref` and is undefined
    T[K] extends Ref<infer V> | undefined
    ? unknown extends V
      ? undefined
      : V | undefined
    : T[K]
}

export type UnwrapRef<T> = T extends ShallowRef<infer V>
  ? V
  : T extends Ref<infer V>
  ? UnwrapRefSimple<V>
  : UnwrapRefSimple<T>

export type UnwrapRefSimple<T> = T extends
  | Function
  | CollectionTypes
  | BaseTypes
  | Ref
  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]
  ? T
  : T extends Array<any>
  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }
  : T extends object & { [ShallowReactiveMarker]?: never }
  ? {
      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>
    }
  : T
```





[id_0]:data:image/png;base64,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