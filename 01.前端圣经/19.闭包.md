## 闭包

> 闭包是有权限访问其他函数作用域内变量的函数(也就是嵌套作用域的引用)

> 引申： 作用域可以视为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域根据标识符名称进行变量查找。简单来说作用域就是变量的有效范围。在一定的空间里可以对变量数据进行读写操作，这个空间就是变量的作用域。即当在js中使用一个变量的时候，首先js引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。


> 闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。[【https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures】](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

```javascript
function init() {
  var name = "Mozilla"; // name 是一个被 init 创建的局部变量
  function displayName() {
    // displayName() 是内部函数，一个闭包
    alert(name); // 使用了父函数中声明的变量
  }
  displayName();
}
init();

```

其中的关键词`函数作用域` `闭包是有权限访问`

作用域是变量和表达式在其中**可见**或**可被访问到的**上下文。如果一个变量或者其他表达式不 “在当前的作用域中”，那么它就是不可用的。换句话说，作用域决定了代码区块中变量和其他资源的可见性(这个，就是为什么闭包是有权限访问的，其根本原因就是，**嵌套的作用域**，也就是作用域链)。正常情况下，函数执行完成，函数内部变量会销毁，内存也会被随之回收，但是由于闭包是建立在一个函数内部的子函数，它是可以访问上级作用域的，所以当内部函数（闭包）没有执行完成时，外部函数中的变量不会被销毁。

### 实现方式

闭包的实现，实际上是利用了JavaScript中作用域链的概念（作用域链）。

### 作用与特点

* 避免污染全局变量（独立的代码执行区域,即实现模块化）
* 闭包产生不会被主动释放，使用完需要主动的释放（也就是常说的延长变量的生命周期），由于这个特点，也可以用于缓存一些数据或者代码运算结果，做数据计算缓存
