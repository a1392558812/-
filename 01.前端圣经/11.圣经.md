## Set 和 Map有什么区别？

1、Map是键值对，Set是值得集合，当然键和值可以是任何得值 

2、Map可以通过get方法获取值，而set不能因为它只有值 

3、都能通过迭代器进行for...of 遍历 

4、Set的值是唯一的可以做数组去重，而Map由于没有格式限制，可以做数据存储 

## Loader和Plugin 有什么区别

* Loader：`n. 装货的人，装货设备，装弹机;装板机`
  * Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以**Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。**
  * 常用的loader
    * file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件
    * source-map-loader：加载额外的 Source Map 文件，以方便断点调试
    * image-loader：加载并且压缩图片文件
    * babel-loader：把 ES6 转换成 ES5
    * css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
    * eslint-loader：通过 ESLint 检查 JavaScript 代码
  
* Plugin：`插件（计算机软件术语）, 插件；插件程序`
  
  * Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
  
  * 常用的plugin
  
    - define-plugin：定义环境变量
    - commons-chunk-plugin：提取公共代码
    - uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码

* loader相较于plugin来说，他的**功能比较单一**，其更专注于对于**文件的转化**这一功能，很强的专一性。且一般只会在资源引用时候加载执行。
* plugin相较于loader来说，其功能更广泛，可以完成打包、资源转化、资源压缩等很多操作，在整个编译周期都会作用，且基于此，能够在整个webpack周期监听其广播的事件。

## 深浅拷贝的区别，实现方式

* 浅拷贝复制对象的引用，而深拷贝创建一个新对象并递归复制所有嵌套的对象。浅拷贝仅复制对象或数组的第一层结构，对于嵌套的对象或数组，仅复制引用而不是实际的对象或数组。常见的浅拷贝方法有 Object.assign()、扩展运算符（...）、Array.slice() 等。

```javascript
    const originalArray = [1, 2, { a: 3 }];
    const shallowCopy = [...originalArray];
    originalArray[2].a = 99;
    console.log(shallowCopy); // [1, 2, { a: 99 }] 
```

* 深拷贝会递归地复制对象或数组及其所有嵌套的对象或数组，生成一份完全独立的副本。深拷贝能够解决浅拷贝中引用传递的问题，确保复制的对象和原对象互不影响。常见的深拷贝方法有使用递归、JSON.parse(JSON.stringify())、第三方库如 lodash 的 _.cloneDeep() 等。

```javascript
   const originalArray = [1, 2, { a: 3 }];
   const deepCopy = JSON.parse(JSON.stringify(originalArray));
   originalArray[2].a = 99;
   console.log(deepCopy); // [1, 2, { a: 3 }]
```


## JSON.stringify拷贝缺点

1. 如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式
2. 如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；
3. 如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；
4. 如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null
5. JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；
6. 如果对象中存在循环引用的情况也无法正确实现深拷贝；

## 箭头函数
* 使用场景
    1. 没有arguments
    2. 不需要指定this的指向或者明确this外层调用者作用域
    3. this取决于父作用域的this
    4. 没有prototype
* 不能使用场景
    1. 对象中的方法：this并不指向这个对象
    2. 原型方法
    3. 构造函数
    4. 动态上下文中的回调函数
    5. vue生命周期和methods中的函数（这条其实就是3的实现）

## emmmmmmm

只有返回resolve之后，then才会被添加到微任务队列中。
process.nextTick 优先级高于 Promise。 setTimeout的优先级高于setIImmediate。

```javascript
console.log('1');

setTimeout(function () {
    console.log('2');
    process.nextTick(function () {
        console.log('3');
    })
    new Promise(function (resolve) {
        console.log('4');
        resolve();
    }).then(function () {
        console.log('5')
    })
})

process.nextTick(function () {
    console.log('6');
})

new Promise(function (resolve) {
    console.log('7');
    resolve();
}).then(function () {
    console.log('8')
})

setTimeout(function () {
    console.log('9');
    process.nextTick(function () {
        console.log('10');
    })
    new Promise(function (resolve) {
        console.log('11');
        resolve();
    }).then(function () {
        console.log('12')
    })
})

// 1 7 6 8 2 4 3 5 9 11 10 12

```

## 类数组转换为数组

```javascript
//通过call调用数组的slice方法来实现转换
Array.prototype.slice.call(arrayLike)

//通过call调用数组的splice方法来实现转换
Array.prototype.splice.call(arrayLike,0)

//通过apply调用数组的concat方法来实现转换
Array.prototype.concat.apply([],arrayLike)

//通过Array.from方法来实现转换
Array.from(arrayLike)

```

