## Set 和 Map有什么区别？

1、Map是键值对，Set是值得集合，当然键和值可以是任何得值 

2、Map可以通过get方法获取值，而set不能因为它只有值 

3、都能通过迭代器进行for...of 遍历 

4、Set的值是唯一的可以做数组去重，而Map由于没有格式限制，可以做数据存储 

## Loader和Plugin 有什么区别

* Loader：`n. 装货的人，装货设备，装弹机;装板机`
  * Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以**Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。**
  * 常用的loader
    * file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件
    * source-map-loader：加载额外的 Source Map 文件，以方便断点调试
    * image-loader：加载并且压缩图片文件
    * babel-loader：把 ES6 转换成 ES5
    * css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
    * eslint-loader：通过 ESLint 检查 JavaScript 代码
  
* Plugin：`插件（计算机软件术语）, 插件；插件程序`
  
  * Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。
  
  * 常用的plugin
  
    - define-plugin：定义环境变量
    - commons-chunk-plugin：提取公共代码
    - uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码

* loader相较于plugin来说，他的**功能比较单一**，其更专注于对于**文件的转化**这一功能，很强的专一性。且一般只会在资源引用时候加载执行。
* plugin相较于loader来说，其功能更广泛，可以完成打包、资源转化、资源压缩等很多操作，在整个编译周期都会作用，且基于此，能够在整个webpack周期监听其广播的事件。

## 深浅拷贝的区别，实现方式

* 浅拷贝复制对象的引用，而深拷贝创建一个新对象并递归复制所有嵌套的对象。浅拷贝仅复制对象或数组的第一层结构，对于嵌套的对象或数组，仅复制引用而不是实际的对象或数组。常见的浅拷贝方法有 Object.assign()、扩展运算符（...）、Array.slice() 等。

```javascript
    const originalArray = [1, 2, { a: 3 }];
    const shallowCopy = [...originalArray];
    originalArray[2].a = 99;
    console.log(shallowCopy); // [1, 2, { a: 99 }] 
```

* 深拷贝会递归地复制对象或数组及其所有嵌套的对象或数组，生成一份完全独立的副本。深拷贝能够解决浅拷贝中引用传递的问题，确保复制的对象和原对象互不影响。常见的深拷贝方法有使用递归、JSON.parse(JSON.stringify())、第三方库如 lodash 的 _.cloneDeep() 等。

```javascript
   const originalArray = [1, 2, { a: 3 }];
   const deepCopy = JSON.parse(JSON.stringify(originalArray));
   originalArray[2].a = 99;
   console.log(deepCopy); // [1, 2, { a: 3 }]
```