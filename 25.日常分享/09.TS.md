## 高级类型

### 交叉类型

> 交叉类型是将多个类型合并为一个类型这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性
>
> 举个🌰：Person & Serializable & Loggable`同时是`Person`与`Serializable`与`Loggable类型的总和
>
> 特点：**同时拥有类型A+B+C...所有的类型**

```ts
function extend<T, U>(first: T, second: U): T & U { // 例如拼接两个对象
    let result = <T & U>{};
    for (let id in first) {
        (<any>result)[id] = (<any>first)[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) {
            (<any>result)[id] = (<any>second)[id];
        }
    }
    return result;
}

class Person {
    /*
    constructor(public name: string) {}为简写
    具体的为
        abstract class Department {
            public name: string;
            constructor(name: string) {
                this.name = name
            }
        }
    emmmmmmmmmm👴都有点忘了emmmmmmmC（ °△ °）C
    */
    constructor(public name: string) { }
}
interface Loggable {
    log(): void;
}
class ConsoleLogger implements Loggable {
    log() {
        // ...
    }
}
var jim = extend(new Person("Jim"), new ConsoleLogger());
var n = jim.name;
jim.log()
```

### 联合类型

> 联合类型与交叉类型很有关联，但是使用上却完全不同。如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。
>
> 特点：**只拥有类型A或者B或者C...中某一个类型和他们共同成员**

```ts
function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft("Hello world", true); // errors during compilation
```

### 类型保护与区分类型

> 联合类型适合于那些值可以为不同类型的情况。 
>
> 如以下代码，当我们想确切地了解是否为 Fish时怎么办？ 

```ts
interface Bird {
    fly();
    layEggs();
}
interface Fish {
    swim();
    layEggs();
}
function getSmallPet(): Fish | Bird { // 此时只能使用返回值的layEggs方法
    // ...
}
```

```ts
let pet = getSmallPet();
// 每一个成员访问都会报错
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}
```

> JavaScript里常用来区分2个可能值的方法是检查成员是否存在。
>
> 但在TS里，我们只能访问联合类型中共同拥有的成员。
>
> 那如何判断

**为了让这段代码工作，我们要使用类型断言：**

```tex
let pet = getSmallPet();
if ((<Fish>pet).swim) {
    (<Fish>pet).swim();
} else {
    (<Bird>pet).fly();
}
```

### 用户自定义的类型保护

> TypeScript里的 *类型保护*机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 *类型谓词*：

```ts
function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}
```

**在这个例子里，`pet is Fish`就是类型谓词。 谓词为 `parameterName is Type`这种形式， `parameterName`必须是来自于当前函数签名里的一个参数名。**

**每当使用一些变量调用 `isFish`时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。**

```ts
// 'swim' 和 'fly' 调用都没有问题了

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
```

> 简单理解“parameterName is Type”做了啥

```ts
interface Bird {
    fly();
    layEggs();
}
interface Fish {
    swim();
    layEggs();
}
function getSmallPet(): Fish | Bird {  // ...  }
// pet is Fish指定参数pet的类型就为Fish类型，我们可以理解为“pet是Fish类型么？”
// emmmmmmmm都疑问句了，返回值是boolean
function isFish(pet: Fish | Bird): pet is Fish { 
    // 假设运行过程中pet的类型就是我们指定的类型：Fish类型，
    // 那么他必然有swim方法
    return (<Fish>pet).swim !== undefined;
}
// 注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型
if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
```

### `typeof`类型保护

```ts
function isNumber(x: any): x is number {
    return typeof x === "number";
}

function isString(x: any): x is string {
    return typeof x === "string";
}

function padLeft(value: string, padding: string | number) {
    if (isNumber(padding)) {
        return Array(padding + 1).join(" ") + value;
    }
    if (isString(padding)) {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```

> 我们可以直接在代码里检查类型，以下代码也生效

```ts
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```

**这些`typeof`类型保护只有两种形式能被识别： **

* **`typeof v === "typename"`与`typeof v !== "typename"`**

	* `"typename"`必须是 `"number"`， `"string"`， `"boolean"`或 `"symbol"`。

	* TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。

### `instanceof`类型保护

> `instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

```ts
interface Padder {
    getPaddingString(): string
}
class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join("👴");
    }
}
class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
        return this.value;
    }
}
function getRandomPadder() {
    return Math.random() < 0.5 ?
        new SpaceRepeatingPadder(4) :
        new StringPadder("  ");
}

// 类型为SpaceRepeatingPadder | StringPadder
let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
    padder; // 类型细化为'SpaceRepeatingPadder'
}
if (padder instanceof StringPadder) {
    padder; // 类型细化为'StringPadder'
}
```

> 如果编译器不能够去除 `null`或 `undefined`，你可以使用类型断言手动去除。 
>
> 语法是添加 `!`后缀，
>
> 如以下代码 `name!`从 `name`的类型里去除了 `null`和 `undefined`：

```ts
function broken(name: string | null): string {
  function postfix(epithet: string) {
    return name.charAt(0) + '.  the ' + epithet; // error, 'name' is possibly null
  }
  name = name || "Bob";
  return postfix("great");
}
function fixed(name: string | null): string {
  function postfix(epithet: string) {
    return name!.charAt(0) + '.  the ' + epithet; // ok
  }
  name = name || "Bob";
  return postfix("great");
}
```

### 类型别名

> 类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。

```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    }
    else {
        return n();
    }
}
// 类型别名可以使用泛型
type MyType<T> = {x:T,y:T};
let value1:MyType<number>;
value1 = {x:111,y:2123};
value1 = {x:'21232',y:1234}; // 不能将类型“string”分配给类型“number”。ts(2322)
```

> 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：

```ts
type Container<T> = { value: T };
type router<T> = {
    router: T;
    childRouter: router<T> | undefined;
    meta: {
        keepAlive?: boolean,
        param?:string
    };
}
// emmmmmmmm这种对象格式感觉基本上不用😅😅😅😅
let obj:router<string> = {
    router:'🍔',
    childRouter:{
        router:'俩🍔',
        childRouter:undefined,
        meta:{},
    },
    meta:{
        keepAlive:true,
        param:'奥利给，干了兄弟们',
    }
}
```

### 字符串字面量类型

> 字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。

```ts
type Easing = "ease-in" | "ease-out" | "ease-in-out";
class UIElement {
    animate(dx: number, dy: number, easing: Easing) {
        if (easing === "ease-in") {
            // ...
        }
        else if (easing === "ease-out") {
        }
        else if (easing === "ease-in-out") {
        }
        else {
            // error! should not pass null or undefined.
        }
    }
}

let button = new UIElement();
button.animate(0, 0, "ease-in");
button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here
// 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。
```

### 可辨识联合

> 合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 *可辨识联合*的高级模式，它也称做 *标签联合*或 *代数数据类型*
>
>  它具有3个要素：
>
> 1. 具有普通的单例类型属性— *可辨识的特征*。
> 2. 一个类型别名包含了那些类型的联合— *联合*。
> 3. 此属性上的类型保护。

```ts
interface Square {
    kind: "square";
    size: number;
}
interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}
interface Circle {
    kind: "circle";
    radius: number;
}
```

首先我们声明了将要联合的接口。 每个接口都有 `kind`属性但有不同的字符串字面量类型。 `kind`属性称做 *可辨识的特征*或 *标签*。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：

```ts
type Shape = Square | Rectangle | Circle;
```

```ts
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
}
```

* 完整性检查

当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。 比如，如果我们添加了 `Triangle`到 `Shape`，我们同时还需要更新 `area`:

```ts
type Shape = Square | Rectangle | Circle | Triangle;
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
    //想让编辑器提示我们，Triangle还没上车呢🚕，应该case ‘Triangle’
}
```

有两种方式可以实现

 1. 首先是启用 `--strictNullChecks`（空指针检查）并且指定一个返回值类型

    ```ts
    function area(s: Shape): number { // error: returns number | undefined
        switch (s.kind) {
            case "square": return s.size * s.size;
            case "rectangle": return s.height * s.width;
            case "circle": return Math.PI * s.radius ** 2;
        }
    }
    // 因为 switch没有包涵所有情况，所以TypeScript认为这个函数有时候会返回 undefined。
    // 如果你明确地指定了返回值类型为 number，那么你会看到一个错误，
    // 因为实际上返回值的类型为 number | undefined
    ```

 2. 第二种方法使用 `never`类型，编译器用它来进行完整性检查：

    ```ts
    interface Square {
        kind: "square";
        size: number;
    }
    interface Rectangle {
        kind: "rectangle";
        width: number;
        height: number;
    }
    interface Circle {
        kind: "circle";
        radius: number;
    }
    interface Triangle {
        kind: "Triangle";
        SideLength1: number;
        SideLength2: number;
        SideLength3: number;
    }
    type Shape = Square | Rectangle | Circle | Triangle;
    function assertNever(x: never): never {
        throw new Error("我还没上车呢🚖🚖🚖🚖: " + x);
    }
    function area(s: Shape) {
        switch (s.kind) {
            case "square": return s.size * s.size;
            case "rectangle": return s.height * s.width;
            case "circle": return Math.PI * s.radius ** 2;
            default: return assertNever(s); // error here if there are missing cases
        }
    }
    ```

### 索引类型

> emmmmmm👆代码🐴

```ts
function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
  return names.map(n => o[n]);
}
```

> ????????????😳😳😳😳😳😳😳

> 做了什么？提出问题
>
> 1. `<T, K extends keyof T>`是啥
>
>    ​	接收参数的类型T与K， K扩展约束T类型的keys的类型，emmmmmmm，简单来说，就是原本K的类型，加上K类型的key值得类型
> 2. `o: T, names: K[]`是啥

