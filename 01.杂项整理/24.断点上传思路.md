* 首先我们是将一个超大的文件进行切片，切割成规定size的小片文件并发上传
* 由于是并发请求，需要告知服务端切片的索引
* 告知服务端前端何时完成切割文件的上传，通知服务端将之前上传的切片按照索引拼接
	* 前端实现思路
	1. 在开始上传前先从服务端验证，是否服务端已存在该文件资源
		
	2. 按照切片的数量创建一个存放切片数组，并映射一个存放对应上传该切片的数组
	
	  * 为什么这么做？
	  > 1. 前端有并发限制，存放数组中可以通过遍历来按照最高并发数来发送请求
	  > 2. 每一个切片数组映射请求数组，即每一个切片对应专属的一个请求，那么发送请求时确保唯一性，同时，为后续拓展（暂停后续传）提供方便
	  > 3. 可以记录下标，更方便确定切片索引，确定其在源文件位置
	  > 4. 可以通过promise.all来记录所有请求发送完毕
	  > 5. 实现暂停上传后的继续上传
	
	3. 无论是前端还是服务端，都必须要生成文件和切片的 hash
	  * 为什么这么做？
	  > 1. 使用文件名 + 切片下标作为切片 hash，这样做文件名一旦修改就失去了效果,只要文件内容不变，hash 就不应该变化
	  > 2. 确保文件唯一性，举个🌰，我的上传文件（杰哥不要啦.avi）与另一个用户上传的文件（杰哥不要啦.avi）是同一个文件，但如果我修改文件名并重新上传，如果使用原来的方法即“文件名+索引”，则服务端会认为这这是两个文件，造成资源浪费
	  > 3. 实现暂停续传，如果当我们上传文件中途暂停（xhr 的 abort 方法）修改文件名再上传，不使用hash,则效果同（2）
	  > 4. 文件秒传实现，hash可以唯一确定一个资源，举个🌰，我的上传文件（杰哥不要啦.avi）与另一个用户“用户A”上传的文件（杰哥不要啦.avi）是同一个文件，我比另一个用户先上传，则服务器就已存在该资源，那么“用户A”就不必上传文件，直接提示其上传成功即可
	
	4. 遍历requestList上传切片，并在所有切片都上传完毕后，再发送一个请求，通知服务端将之前的切片按照索引拼接
	
	5. 暂停上传（xhr 的 `abort `方法或者Axios 内部提供的 `CancelToken`）
	
	6. 恢复上传
	
	   1. 请求服务端获取已经上传的切片，将其从requestList中过滤，上传剩余的requestList
	   2. 每当一个切片上传成功时，将其requestList 中删除，requestList 中只保存正在上传的切片

## 参考

https://juejin.cn/post/6844904046436843527#heading-18

https://zhuanlan.zhihu.com/p/104826733

https://juejin.cn/post/6977555547570569223

