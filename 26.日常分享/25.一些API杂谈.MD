## will-change

> [CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) 属性 `will-change` 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。
>
> 1. **不要将 will-change 应用到太多元素上**(只给即将开启动画的元素添加)
> 2. **有节制地使用**(will-change告诉浏览器，目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久，最佳实践是当元素变化之前和之后通过脚本来切换 `will-change` 的值，即我们需要使用js来动态的控制will-change的添加)
> 3. **不要过早应用 will-change 优化**（will-change是我们最后的优化手段，而不是首选）
> 4. **给它足够的工作时间**

```js
var el = document.getElementById('element');
// 当鼠标移动到该元素上时给该元素设置 will-change 属性
el.addEventListener('mouseenter', hintBrowser);
// 当 CSS 动画结束后清除 will-change 属性
el.addEventListener('animationEnd', removeHint);
function hintBrowser() {
  // 填写上那些你知道的，会在 CSS 动画中发生改变的 CSS 属性名们
  this.style.willChange = 'transform, opacity';
}
function removeHint() {
  this.style.willChange = 'auto';
}
```

## Vue.observable( object )

> 让一个对象可响应。Vue 内部会用它来处理 `data` 函数返回的对象。返回的对象可以直接用于[渲染函数](https://cn.vuejs.org/v2/guide/render-function.html)和[计算属性](https://cn.vuejs.org/v2/guide/computed.html)内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：

```vue
const state = Vue.observable({ count: 0 })
const Demo = {
  render(h) {
    return h('button', {
      on: { click: () => { state.count++ }}
    }, `count is: ${state.count}`)
  }
}
```

> 如果该state可以通过.操作符来进行读写，那数据流向就不好掌握，如何进行读写分离
>
> 
