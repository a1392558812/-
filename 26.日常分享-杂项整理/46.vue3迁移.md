## vue3迁移

> emmmmm自己备忘用，有一些容易记得就不写了
>
> 以下内容都来自官网

迁移补充 `vue3解决了什么`

> 1. 组件逻辑膨胀导致的可读性变差
> 2. 无法跨组件重用代码(mixin很弱)
> 3. 对jsx支持度更高
> 4. this很模糊（底层this的模糊性，导致对ts支持度不高，我们不需要关系），在我们使用时，setup解决了这个
> 5. Treeshaking减少代码包

### $on，$off 和 $once 实例方法已被移除，组件实例不再实现事件触发接口

### `$children` 实例 property 已从 Vue 3.0 中移除，不再支持

* 迁移策略：
  * 需要访问子组件实例，我们建议使用 [$refs](https://v3.cn.vuejs.org/guide/component-template-refs.html#模板引用)

    ```html
    <base-input ref="usernameInput"></base-input>
    ```

    ```js
    this.$refs.usernameInput.focusInput()
    ```
    
  * `$refs` 只会在组件渲染完成之后生效。这仅作为一个用于直接操作子元素的“逃生舱”——你应该避免在模板或计算属性中访问 `$refs`。

### 定制自定义元素

* 自定义元素规范提供了一种将自定义元素作为[自定义内置模板](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example)的方法，方法是向内置元素添加 `is` 属性：

```html
<button is="plastic-button">点击我!</button>
```

## Mixin 合并行为变更

>  此外，当来自组件的 `data()` 及其 mixin 或 extends 基类被合并时，现在将*浅层次*执行合并：

> 我套你🐵猴子的，都有setup了，谁还用minxin，老难维护了。

```js
const Mixin = {
  data() {
    return {
      user: {
        name: 'Jack',
        id: 1
      }
    }
  }
}
const CompA = {
  mixins: [Mixin],
  data() {
    return {
      user: {
        id: 2
      }
    }
  }
}
```

在 Vue 2.x 中，生成的 `$data` 是：

```json
{
  "user": {
    "id": 2,
    "name": "Jack"
  }
}
```

在 3.0 中，其结果将会是：

```json
{
  "user": {
    "id": 2
  }
}
```

### 事件 API

> 在绝大多数情况下，不鼓励使用全局的 event bus 在组件之间进行通信。虽然在短期内往往是最简单的解决方案，但从长期来看，它维护起来总是令人头疼。

* `$on`，`$off` 和 `$once` 实例方法已被移除，组件实例不再实现事件触发接口
* Event bus 模式可以被替换为实现了事件触发器接口的外部库，例如 [mitt](https://github.com/developit/mitt) 或 [tiny-emitter](https://github.com/scottcorgan/tiny-emitter)。

###  过滤器

> 从 Vue 3.0 开始，过滤器已删除，不再支持
>
> 在v2.0时，我觉得这个Api很废，明明用计算属性就能完成，非脱了👖放屁

* 全局过滤器
  * 如果在应用中全局注册了过滤器，那么在每个组件中用计算属性或方法调用来替换它可能就没那么方便了。取而代之的是，你可以通过[全局属性](https://v3.cn.vuejs.org/api/application-config.html#globalproperties)以让它能够被所有组件使用到：

  ```js
  // main.js
  const app = createApp(App)
  
  app.config.globalProperties.$filters = {
    currencyUSD(value) {
      return '$' + value
    }
  }
  ```

  然后，可以通过这个 `$filters` 对象修正所有的模板，就像这样：

    ```html
    <template>
      <h1>Bank Account Balance</h1>
      <p>{{ $filters.currencyUSD(accountBalance) }}</p>
    </template>
    ```
  
  注意，这种方式只适用于方法，而不适用于计算属性，因为后者只有在单个组件的上下文中定义时才有意义。

### 函数式组件

> emmmmmmm那是不是更好的支持jsx了？！

### 全局api

* `Vue.extend` 移除

  * 组件api ` extends`

    * 允许一个组件扩展到另一个组件，且继承该组件选项。

      从实现的角度看，`extends` 几乎等同于 `mixins`。可以认为其作为第一个 mixin 作用在被 `extends` 的组件上。

      然而，`extends` 和 `mixins` 表达了不同的意图。`mixins` 选项主要用来组合功能，而 `extends` 主要用来考虑继承性。

      和 `mixins` 类似，任何选项都会通过对应的合并策略被合并。

    * ```js
      const CompA = { ... }
      
      const CompB = {
        extends: CompA,
        ...
      }
      ```

* `config.ignoredElements` 替换为 `config.isCustomElement`

* `Vue.prototype` 替换为 `config.globalProperties`

* 移除`$listeners`

* 支持多个应用根实例，防止全局配置污染

  * ```js
    // vue2
    // 这会影响两个根实例
    Vue.mixin({
      /* ... */
    })
    const app1 = new Vue({ el: '#app-1' })
    const app2 = new Vue({ el: '#app-2' })
    ```

  * ```js
    // vue3
    import { createApp } from 'vue'
    
    const app = createApp({})
    app.mixin({
      /* ... */
    })
    ```


### VNode 生命周期事件

## 概述

在 Vue 2，我们可以通过事件来监听组件生命周期中的关键阶段。这些事件名都是以 `hook:` 开头并跟随相应的生命周期钩子的名字。

在 Vue 3，这些前缀会被改为 `vnode-`。额外地，这些事件在 HTML 元素上也可用，和在组件上的用法一样。

## [2.x](https://v3.cn.vuejs.org/guide/migration/vnode-lifecycle-events.html#_2-x-语法) 语法

在 Vue 2，这些事件名和生命周期钩子一样，并附带 `hook:` 的前缀：

```html
<template>
  <child-component @hook:updated="onUpdated">
</template>
```

## [3.x](https://v3.cn.vuejs.org/guide/migration/vnode-lifecycle-events.html#_3-x-语法) 语法

在 Vue 3，事件名附带的是 `vnode-` 前缀：

```html
<template>
  <child-component @vnode-updated="onUpdated">
</template>
```

或者在驼峰命名法的情况下附带前缀 `vnode`：

```html
<template>
  <child-component @vnodeUpdated="onUpdated">
</template>
```

### setup中的data

* ref，接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property `.value`。
  * 可以生成`值类型`（即基本数据类型） 的响应式数据
  * 可以用于**模板**和**reactive**
  * 通过 `.value` 来修改值（注意一定要记得加上 `.value` ）
  * 不仅可以用于**响应式**，还可以用于模板的 `DOM` 元素
  * ref背后也是通过reactive实现的
  
* reactive， 返回对象的响应式副本，即一个深层递归转换的proxy对象。
  * 一般**基础数据类型**使用ref，**对象**使用reactive
  * 如果将对象分配为 ref 值，则通过 [reactive](https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Fbasic-reactivity.html%23reactive) 方法使该对象具有高度的响应式。

* readonly， 接受一个对象 (响应式或纯对象) 或 [ref](https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Frefs-api.html%23ref) 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。

  *  比如一些table数据，就可以为readonly，几乎不怎么改

* unref， 如果参数是一个 [`ref`](https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Frefs-api.html%23ref)，则返回内部值，否则返回参数本身。这是 `val = isRef(val) ? val.value : val` 的语法糖函数。

  * emmmmmmmmm，没啥好说的，感觉这种东西让第三方库实现即可

* toRaw， 返回reactive或readonly代理的原始对象。这是一个转义口，可用于临时读取而不会引起代理访问/跟踪开销，也可用于写入而不会触发更改。不建议保留对原始对象的持久引用。请谨慎使用。

  ```js
  const foo = {}
  const reactiveFoo = reactive(foo)
  
  console.log(toRaw(reactiveFoo) === foo) // true

* toRef， 可以用来为源响应式对象上的某个 property 新创建一个 [`ref`](https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Frefs-api.html%23ref),它会保持对其源 property 的响应式连接。

  > 我的理解就是**语法糖**，就是满足reactive包装的响应式对象中的某个属性需要单独做个响应式时简便写法，即创建一个引用
  >
  > emmmmm用处有些方便嗷！！

  ```js
  const state = reactive({
    foo: 1,
    bar: 2
  })
  
  const fooRef = toRef(state, 'foo')
  
  fooRef.value++
  console.log(state.foo) // 2
  
  state.foo++
  console.log(fooRef.value) // 3
  ```

 * toRefs， 将**响应式对象转换为普通对象，但里面的每个属性都是响应式的，**其中结果对象的每个 property 都是指向原始对象相应 property 的 [`ref`](https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Frefs-api.html%23ref)，不会丢失响应性

    * 不会丢失响应性要识别数据是否使用toRefs处理过，可以使用这些api：`isRef`、`isProxy`、`isReactive`、`isReadonly`。

   - 与`toRef`不一样的是， `toRefs`是针对整个对象的所有属性，目标在于将响应式对象（ `reactive` 封装）转换为普通对象
   - 普通对象里的每一个属性都对应一个`ref`

   > 作用：可以使得一个响应式对象可解构

   ```js
   function useFeatureX() {
     const state = reactive({
       foo: 1,
       bar: 2
     })
     // 操作 state 的逻辑
     // 返回时转换为ref
     return toRefs(state)
   }
   
   export default {
     setup() {
       // 可以在不失去响应性的情况下解构
       const { foo, bar } = useFeatureX()
   
       return {
         foo,
         bar
       }
     }
   }
   ```
   
   > 1. 与`ref`不一样， `toRef`和`toRefs`**不创造响应式**，而是**延续响应式**。
   >
   > 2. **创造响应式**一般由`ref`或者 `reactive` 来解决
   > 3. 而`toRef`和`toRefs`则是把响应式对象的数据变得可以使得**单独作用(某个属性)**和**解构**，便于数据向下流与追踪，
   > 4. 这个对象针对的是**响应式对象**而**非普通对象**
   
* customRef， 创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收`track`和`trigger`函数作为参数，并应返回一个带有`get`和`set`的对象。

    ```js
    <template>
      <input v-model="text" />
    <template/>
          
    <script>
        import { useDebouncedRef } from './useDebouncedRef.js'
        export default {
          setup() {
            return {
              text: useDebouncedRef('hello')
            }
          }
        }
    <script/>
    ```

    ```js
    import { customRef } from 'vue'
    function useDebouncedRef(value, delay = 200) {
      let timeout
      return customRef((track, trigger) => {
        return {
          get() {
            track() // 追踪当前数据
            return value
          },
          set(newValue) {
            clearTimeout(timeout)
            timeout = setTimeout(() => {
              value = newValue
              trigger() // 触发响应,即更新界面
            }, delay)
          }
        }
      })
    }
    ```

*  computed， 接收一个函数并返回一个value为getter返回值的不可改变的响应式ref对象

* watch， 就是vue2的`this.$watch`，小样！穿了个马甲我就不认识你了

    > emmmmm有点变化，马甲穿的花哨了

    *  清除副作用，**onCleanup**
    
    ```js
    const getData = (value) => {
    	const handler = setTimeout(() => {
    		console.log('数据', value)
    	}, 5000)
    	return handler
    }
    
    const inputRef = ref('')
    watch(inputRef, (val, oldVal, onCleanup) => {
    	const handler = getData(val) // 异步操作
    	// 清除副作用
    	onCleanup(() => {
    		clearTimeout(handler)
    	})
    })
    return {inputRef}
    ```
    
    * 停止监听, **stopWatch**
    
    ```js
    setup{
    	const stopWatch = watch('xxxx');
    	// 执行即可停止监听
    	// watch返回一个函数 function(){ stop() }
    	stopWatch()
    	return {};
    }
    ```
    
* watchEffect， `watchEffect`函数不用指明监听哪个属性，监听的回调中用到哪个属性，就监听哪个属性。在响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。默认初始化时会执行一次。
    * 会立即执行副作用方法。并且当内部所依赖的响应式值发生改变时也会重新执行
    * 不需要指定监听属性，可以自动收集依赖
    * 可以通过`onInvalidate` 取消监听

    ```js
    setup{
    	  const person = reactive({
          name: '张三',
          age: 20,
          job: {
            jobName: '工程师',
            area: {
              areaName: '上海'
            }
          }
        })
        setTimeout(() => {
          person.name = '李四'
          person.age = 30
          person.job.jobName = '设计师'
          console.log('--------');
        }, 1000)
        
        watchEffect(() => {
          console.log(person.name, 'watchEffect--')
          console.log(person.job.jobName, 'watchEffect++')
          onInvalidate(() => {
            // TODO
          })
        })
    }
    ```

    > **watchEffect**不需要指定监听的属性，他会自动的收集依赖，只要在回调函数中引用到了响应式的属性，那么当这些属性变动的时候，这个回调都会执行，而**watch**只能监听指定的属性而作出变动(vue3开始能够同时指定多个)
    >
    > **watch**能够获取到新值与旧值（更新前的值），而**watchEffect**是拿不到的
    >
    > **watchEffect**在组件初始化的时候就会执行一次用以收集依赖，收集到的依赖发生变化时再执行。而**watch**则是直接指定依赖项
